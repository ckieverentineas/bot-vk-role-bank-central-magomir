import { Keyboard, KeyboardBuilder } from "vk-io"
import { Accessed, Logger, Send_Message, Send_Message_Detected } from "../../../core/helper"
import { answerTimeLimit, chat_id } from "../../../.."
import prisma from "../prisma_client"
import { ico_list } from "../data_center/icons_lib"
import { Back } from "./operation_global"
import { Editor } from "./person_editor"
import { User } from "@prisma/client"

//–ú–æ–¥—É–ª—å –¥–æ–ø –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
export async function Sub_Menu(id: number, context: any, user_adm: User) {
    const keyboard = new KeyboardBuilder()
    keyboard.textButton({ label: '‚úè', payload: { command: 'editor' }, color: 'secondary' })
    .textButton({ label: 'üëÅüëú', payload: { command: 'inventory_show' }, color: 'secondary' }).row()
    .textButton({ label: 'üîô', payload: { command: 'back' }, color: 'secondary' }).row()
    .textButton({ label: 'üë†', payload: { command: 'user_drop' }, color: 'secondary' }).row()
    if (await Accessed(context) == 3) { keyboard.textButton({ label: '‚ò†', payload: { command: 'user_delete' }, color: 'secondary' }) }
    const ans_again: any = await context.question( `‚úâ –î–æ—Å—Ç—É–ø–Ω—ã —Å–ª–µ–¥—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å üí≥UID: ${id}`, { keyboard: keyboard.oneTime().inline(), answerTimeLimit })
    await Logger(`In a private chat, the sub menu for user ${id} is viewed by admin ${context.senderId}`)
    if (ans_again.isTimeout) { return await context.send(`‚è∞ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –Ω–∞ –≤–≤–æ–¥ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å üí≥UID: ${id} –∏—Å—Ç–µ–∫–ª–æ!`) }
    const config: any = {
        'back': Back,
        'inventory_show': Inventory_Show,
        'user_delete': User_delete,
        'user_drop': User_Drop,
        'editor': Editor,
    }
    if (ans_again?.payload?.command in config) {
        const commandHandler = config[ans_again.payload.command];
        const answergot = await commandHandler(Number(id), context, user_adm)
    } else {
        await context.send(`‚öô –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.`)
    }
}

async function User_Drop(id: number, context: any, user_adm: User) {
    const user_get: any = await prisma.user.findFirst({ where: { id: id } })
    const confirmq = await context.question(`‚Åâ –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–ø–Ω—É—Ç—å —Å —Ä–æ–ª–µ–≤–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ ${user_get.name}`,
        {
            keyboard: Keyboard.builder()
            .textButton({ label: '–î–∞', payload: { command: 'confirm' }, color: 'secondary' })
            .textButton({ label: '–ù–µ—Ç', payload: { command: 'gold_down' }, color: 'secondary' })
            .oneTime().inline(),
            answerTimeLimit
        }
    )
    if (confirmq.isTimeout) { return await context.send(`‚è∞ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–∏–Ω–∫–∞ –¥–ª—è ${user_get.name} –∏—Å—Ç–µ–∫–ª–æ!`) }
    if (confirmq.payload.command === 'confirm' && user_get) {
        if (user_get) {
            // –º–æ–¥—É–ª—å –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏—è —Å –±–∞–ª–ª–∞–º–∏
            let answer_check = false
            let rank_action = null
            while (answer_check == false) {
                const answer_selector = await context.question(`üß∑ –£–∫–∞–∂–∏—Ç–µ —á—Ç–æ –±—É–¥–µ–º –¥–µ–ª–∞—Ç—å —Å –±–∞–ª–ª–∞–º–∏ —É—á–µ–Ω–∏–∫–∞ –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –≤ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç –∑–∞ —Ç–µ–∫—É—â–∏–π —É—á–µ–±–Ω—ã–π –≥–æ–¥:`,
                    {	
                        keyboard: Keyboard.builder()
                        .textButton({ label: '–ù–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞—Ç—å', payload: { command: 'student' }, color: 'secondary' }).row()
                        .textButton({ label: '–û–±–Ω—É–ª–∏—Ç—å', payload: { command: 'professor' }, color: 'secondary' }).row()
                        .oneTime().inline(), answerTimeLimit
                    }
                )
                if (answer_selector.isTimeout) { return await context.send(`‚è∞ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –≤—ã–±–æ—Ä–∞ —Å—Ç–∞—Ç—É—Å–∞ –∏—Å—Ç–µ–∫–ª–æ!`) }
                if (!answer_selector.payload) {
                    await context.send(`üí° –ñ–º–∏—Ç–µ —Ç–æ–ª—å–∫–æ –ø–æ –∫–Ω–æ–ø–∫–∞–º —Å –∏–∫–æ–Ω–∫–∞–º–∏!`)
                } else {
                    rank_action = answer_selector.text
                    answer_check = true
                }
            }
            const alli_get = await prisma.alliance.findFirst({ where: { id: Number(id) } })
            const user_del = await prisma.user.update({ where: { id: id }, data: { id_alliance: 0, id_facult: 0, id_role: 1 } })
            await context.send(`‚ùó –í—ã–ø–Ω—É—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${user_del.name}`)
            const notif_ans = await Send_Message_Detected(user_del.idvk, `‚ùó –í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–∂ üí≥UID: ${user_del.id} –±–æ–ª—å—à–µ –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ä–æ–ª–µ–≤–æ–π.`)
            !notif_ans ? await context.send(`‚öô –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${user_del.name} –Ω–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ`) : await context.send(`‚öô –û–ø–µ—Ä–∞—Ü–∏—è –ø–∏–Ω–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ.`)
            const ans_log = `‚öô @id${context.senderId}(${user_adm.name}) > "üë†üë§" > –∏—Å–∫–ª—é—á–∞–µ—Ç –∏–∑ —Ä–æ–ª–µ–≤–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ —Ä–æ–ª–µ–≤–∏–∫–∞ @id${user_del.idvk}(${user_del.name})`
            if (alli_get) { await Send_Message(alli_get.id_chat, ans_log) }
            await Send_Message(chat_id, ans_log)
            await Logger(`In database, updated status user: ${user_del.idvk}-${user_del.id} on SOLO by admin ${context.senderId}`)
            // –î–≤–∏–∂–æ–∫ –º–æ–¥—É–ª—è –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π —Å –±–∞–ª–ª–∞–º–∏
            const alli_fac = await prisma.allianceFacult.findFirst({ where: { id: user_get.id_facult! } })
            switch (rank_action) {
                case '–ù–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞—Ç—å':
                    break;
                case '–û–±–Ω—É–ª–∏—Ç—å':
                    for (const coin of await prisma.allianceCoin.findMany({ where: { id_alliance: user_get.id_alliance! } })) {
                        if (coin.point == false) { continue }
                        const bal_fac = await prisma.balanceFacult.findFirst({ where: { id_coin: coin.id, id_facult: user_get.id_facult! }})
                        const bal_usr = await prisma.balanceCoin.findFirst({ where: { id_coin: coin.id, id_user: user_get.id }})
                        if ( !bal_fac || !bal_usr) { continue }
                        const bal_fac_ch = await prisma.balanceFacult.update({ where: { id: bal_fac.id }, data: { amount: { decrement: bal_usr.amount } } })
                        const bal_usr_ch = await prisma.balanceCoin.update({ where: { id: bal_usr.id }, data: { amount: 0 } })
                        const ans_log = `üåê "${rank_action}${coin.smile}" > ${bal_fac.amount} - ${bal_usr.amount} = ${bal_fac_ch.amount} –¥–ª—è –§–∞–∫—É–ª—å—Ç–µ—Ç–∞ [${alli_fac!.smile} ${alli_fac!.name}], –±–∞–ª–∞–Ω—Å: ${bal_usr_ch.amount}${coin.smile} –∏–∑-–∑–∞ –∫—Ä–æ—Ç–∞ @id${user_get.idvk}(${user_get.name})`
                        const notif_ans_chat = await Send_Message_Detected(alli_get?.id_chat ?? 0, ans_log)
                        if (!notif_ans_chat) { await Send_Message(chat_id, ans_log) } 
                    }
                    break;
                default:
                    break;
            }
        } 
    } else {
        await context.send(`‚öô –ü–∏–Ω–æ–∫ —Ä–æ–ª–µ–≤–∏–∫–∞ ${user_get.name} –æ—Ç–º–µ–Ω–µ–Ω.`)
    }
}

//–ú–æ–¥—É–ª—å —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
async function User_delete(id: number, context: any, user_adm: User) {
    const user_get: any = await prisma.user.findFirst({ where: { id: id } })
    const confirmq = await context.question(`‚Åâ –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –∫–ª–∏–µ–Ω—Ç–∞ ${user_get.name}`,
        {
            keyboard: Keyboard.builder()
            .textButton({ label: '–î–∞', payload: { command: 'confirm' }, color: 'secondary' })
            .textButton({ label: '–ù–µ—Ç', payload: { command: 'gold_down' }, color: 'secondary' })
            .oneTime().inline(),
            answerTimeLimit
        }
    )
    if (confirmq.isTimeout) { return await context.send(`‚è∞ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–∏—è ${user_get.name} –∏—Å—Ç–µ–∫–ª–æ!`) }
    if (confirmq.payload.command === 'confirm' && user_get) {
        if (user_get) {
            const user_del = await prisma.user.delete({ where: { id: id } })
            await context.send(`‚ùó –£–¥–∞–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${user_del.name}`)
            if (user_del) {
                const check_bbox = await prisma.blackBox.findFirst({ where: { idvk: user_del.idvk } })
                if (!check_bbox) {
                    const add_bbox = await prisma.blackBox.create({ data: { idvk: user_del.idvk } })
                    add_bbox ? await context.send(`‚öô @id${user_del.idvk}(${user_del.name}) —Ç–µ–ø–µ—Ä—å —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–ª–µ–≥–∞–ª–æ–º.`) : await context.send(`‚öô @id${user_del.idvk}(${user_del.name}) –Ω–µ —Å–º–æ–≥ —Å—Ç–∞—Ç—å –Ω–µ–ª–µ–≥–∞–ª–æ–º.`)
                } else {
                    await context.send(`‚öô @id${user_del.idvk}(${user_del.name}) –¥–µ–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –ù–ê –†–û–î–ò–ù–£ —É–∂–µ –Ω–µ –≤ –ø–µ—Ä–≤—ã–π —Ä–∞–∑.`)
                }
                const notif_ans = await Send_Message_Detected(user_del.idvk, `‚ùó –í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–∂ üí≥UID: ${user_del.id} –±–æ–ª—å—à–µ –Ω–µ –æ–±—Å–ª—É–∂–∏–≤–∞–µ—Ç—Å—è. –°–ø–∞—Å–∏–±–æ, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞–ª–∏—Å—å –¶–µ–Ω—Ç—Ä–æ–±–∞–Ω–∫–æ–º –ú–∞–≥–æ–º–∏—Ä–∞ –û–Ω–ª–∞–π–Ω üè¶, ${user_del.name}. –í–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ –Ω–∞–º —Å–Ω–æ–≤–∞!`)
                !notif_ans ? await context.send(`‚öô –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${user_del.name} –Ω–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ`) : await context.send(`‚öô –û–ø–µ—Ä–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ.`)
                const ans_log = `‚öô @id${context.senderId}(${user_adm.name}) > "üö´üë§" > —É–¥–∞–ª—è–µ—Ç—Å—è –∏–∑ –±–∞–Ω–∫–æ–≤—Å–∫–æ–π —Å–∏—Å—Ç–µ–º—ã –∫–∞—Ä—Ç–æ—á–∫–∞ @id${user_del.idvk}(${user_del.name})`
                await Send_Message(chat_id, ans_log)
            }
            await Logger(`In database, deleted user: ${user_del.idvk}-${user_del.id} by admin ${context.senderId}`)
        } 
    } else {
        await context.send(`‚öô –£–¥–∞–ª–µ–Ω–∏–µ ${user_get.name} –æ—Ç–º–µ–Ω–µ–Ω–æ.`)
    }
}

async function Inventory_Show(id: number, context: any, user_adm: User) { 
    const artefact = await prisma.inventory.findMany({ where: { id_user: id } })
    if (artefact.length > 0) {
        for(const element of artefact) {
            const item: any = await prisma.item.findFirst({ where: { id: element.id_item }, include: { category: true } })
            await context.send(`üí¨: ${item.name}-${element.id} \n üîß: ${item.category.name}-${item.price}${ico_list.medal.ico}`,
                {
                    keyboard: Keyboard.builder()
                    .textButton({ label: '–£–¥–∞–ª–∏—Ç—åüëú', payload: { command: `${element.id}` }, color: 'secondary' })
                    .oneTime().inline()
                }
            )
        }
    } else {
        await context.send(`‚úâ –¢–æ–≤–∞—Ä—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç =(`)
    }
    await Logger(`In private chat, the inventory user uid ${id} is viewed by admin ${context.senderId}`)
}